var net = require('net'),
    events = require('events'),
    util = require('util'),
    http = require('http'),
    https = require('https'),
    crypto = require('crypto'),
    querystring = require('querystring'),
    child_process = require('child_process'),
    fs = require('fs');

var Packet = require(__dirname + '/packet.js'),
    protocol = require(__dirname + '/protocol.js'),
    constants = require(__dirname + '/constants.js');

var stringCodes = {
    '0': '30',
    '1': '94',
    '2': '32',
    '3': '36',
    '4': '31',
    '5': '95',
    '6': '93',
    '7': '39',
    '8': '90',
    '9': '34',
    'a': '92',
    'b': '35',
    'c': '91',
    'd': '95',
    'e': '93',
    'f': '33',

    'k': '11',
    'l': '1',
    'm': '9',
    'n': '4',
    'o': '3',
    'r': '0'
};

function minecraftToAnsi(string) {
    return string;

    var escaped = string.replace(/(\u00a7(.))/gi, function(match, p1, p2) {
        return '\033[0' + (stringCodes[p2] || '0') + 'm';
    });

    if(escaped !== string) return '\033[00m' + escaped;
    return string;
}

/** @constructor */
var Socket = function(options) {
    events.EventEmitter.call(this);

    options = options || {};
    if(typeof options.username !== 'undefined') this.username = options.username;
    if(typeof options.password !== 'undefined') this.password = options.password;

    this.isServer = options.isServer || false;

    this.connected = false;
    this.loggedIn = false;
    this.version = options.version || 13;

    this._closed = false;
    this._encrypted = false;

    this.keepAlive = options.keepAlive && true;
    this.keepAliveInterval = options.keepAliveInterval || 4 * 1000;
    this.timeout = options.timeout || 10 * 1000;
    this._lastKeepAlive = null;

    this.convertToAnsi = options.convertToAnsi && true;

    this._writeQueue = [];
    this._writeLock = false;
    
    this._readQueue = [];
    this._readAppend = false;
    this._readLock = false;
    
    this._receivedKicks = false;

    this.bytesRead = 0;
    this.bytesWritten = 0;

    this.socket = options.socket || new net.Socket();

    if(!this.isServer) {
        this.on(0x00, function(data) {
            if(this.keepAlive) this.write(0x00, data);
        }.bind(this));
    } else {
        this.on(0x00, function(data) {
            if(this.keepAlive) this._lastKeepAlive = Date.now();
            else this._lastKeepAlive = null;
        });

        var keepAliveLoop = function() {
            if(this.keepAlive) {
                // check if last keepalive was too long ago (timeout)
                if(this._lastKeepAlive) {
                    var elapsed = Date.now() - this._lastKeepAlive;
                    if(elapsed > this.timeout) {
                        this.close('Connection timed out');
                        return;
                    }
                }

                this.write(new Packet(0x00, {
                    keepAliveId: Math.floor(Math.random() * 2147483648)
                }));
            }

            setTimeout(keepAliveLoop, this.keepAliveInterval);
        }.bind(this);

        keepAliveLoop();
    }

    if(!this.isServer) {
        this.on(0xff, function(data) {
            this.socket.destroy();
            this.emit('close', data.reason);
        }.bind(this));
    }

    this.socket.on('error', this.error.bind(this));

    this.socket.on('data', function(data) {
        if(this._closed) return;

        if(this._encrypted) {
            data = new Buffer(this.decipher.update(data.toString('binary'), 'binary', 'binary'), 'binary');
        }

        this.socket.pause();
        if(this._readAppend) {
            this._readQueue[0] = cat(this._readQueue[0], data);
            this._readAppend = false;
        } else {
            this._readQueue.push(data);
        }
        this.socket.resume();
        
        if(!this._readLock) {
            this._readLock = true;
            
            var read = function() {
                if(this._readQueue.length > 0) {
                    if(!this.isServer && !this._receivedKicks && this._readQueue[0].length > 4 &&
                    this._readQueue[0].readUInt32BE(0) === 0xffffffff) {
                        this._receivedKicks = true;
                        this._readQueue.shift();
                    } else {
                        var packet = this.decode(this._readQueue[0]);

                        if(packet === true) {
                            if(this._readQueue.length > 1) {
                                this.socket.pause();
                                var head = this._readQueue.shift();
                                this.socket.resume();
            
                                this._readQueue[0] = cat(head, this._readQueue[0]);
                            } else {
                                this._readAppend = true;
                            }
                        } else if(packet === false) {
                            var id = this._readQueue[0].readUInt8(0);
                            console.log(this._readQueue[0]);
                            this.error('Error reading incoming data with id 0x'+id.toString(16));

                            process.exit();
            
                            this.socket.pause();
                            this._readQueue.shift();
                            this.socket.resume();
                        } else {
                            if(this.convertToAnsi) {
                                for(var i in packet.data) {
                                    if(typeof packet.data[i] === 'string') {
                                        packet.data[i] = minecraftToAnsi(packet.data[i]);
                                    }
                                }
                            }
                            this.emit('data', packet);
                            this.emit(packet.id, packet.data);
                            this.bytesRead += packet._size;
            
                            if(this._readQueue[0].length > packet._size) {
                                this._readQueue[0] = this._readQueue[0].slice(packet._size);
                            } else {
                                this.socket.pause();
                                this._readQueue.shift();
                                this.socket.resume();
                            }
                        }
                    }
        
                    process.nextTick(read);
                } else {
                    this._readLock = false;
                }
            }.bind(this);
            read();
        }
    }.bind(this));

    var onClose = function() {
        if(!this._closed) this.close('Connection closed by ' + (this.isServer ? 'client' : 'server'));
    }.bind(this);

    this.socket.on('end', onClose);
    this.socket.on('close', onClose);
    this.on(0xff, onClose);

    this.socket.on('drain', function() {
        this._writeLock = false;
        while(this._writeQueue.length > 0) {
            this.write(this._writeQueue.shift());
        }
    }.bind(this));
};
util.inherits(Socket, events.EventEmitter);

Socket.prototype.write = function(packet, data) {
    if(this._closed) return;

    if(typeof data !== 'undefined') {
        var format = protocol.get(packet, !this.isServer);
        if(typeof format !== 'undefined') {
            this.write(new Packet(packet, data, !this.isServer));
        } else {
            this.error('Invalid packet id (0x' + packet.toString(16) + ')');
        }
    } else {
        if(!(packet instanceof Buffer)) {
            data = packet.toString('buffer');

            if(this._encrypted) {
                data = new Buffer(this.cipher.update(data.toString('binary'), 'binary', 'hex'), 'hex');
            }
        } else {
            data = packet;
        }

        if(this._writeLock) {
            this._writeQueue.push(data);
        } else {
            if(!this.socket.write(data)) {
                this._writeLock = true;
                this._writeQueue.push(data);
            } else {
                try {
                    this.bytesWritten += packet.getSize();
                } catch(e) {
                    this.error('Could not get size of written packet')
                }
            }
        }
    }

    return this;
};

Socket.prototype.decode = function(buf) {
    if(typeof buf !== 'undefined' && buf.length > 0) {
        var id = buf.readUInt8(0);
        var packet = {};
        var format = protocol.get(id, this.isServer);
        
        if(typeof format !== 'undefined') {
            try {
                buf = buf.slice(1);

                var size = 1;

                for(var i = 0; i < format.length; i++) {
                    var unpack = protocol.datatypes[format[i].type.toUpperCase()].unpack(buf);

                    if(unpack === false) {
                        return false;
                    } else {
                        buf = buf.slice(unpack.bytes);
                        size += unpack.bytes;

                        packet[format[i].name] = unpack.value;
                    }
                }
                packet = new Packet(id, packet, this.isServer);
                packet._size = size;

                return packet;
            } catch(e) {
                return true;
            }
        } else {
            return false;
        }
    } else {
        return true;
    }
};

Socket.prototype.login = function(callback) {
    if(!this.loggedIn) {
        if(typeof callback == 'function') this.once('login', callback);

        var postData = querystring.stringify({
            user: this.username,
            password: this.password,
            version: this.version
        });

        var req = https.request({
            host: 'login.minecraft.net',
            method: 'POST',
            headers: {
                'Content-Type': 'application/x-www-form-urlencoded',
                'Content-Length': postData.length
            }
        }, function(res) {
            res.once('data', function(chunk) {
                console.log(chunk)
                var split = chunk.toString().split(':');
                if(split.length === 5) {
                    this._login = {
                        currentVersion: split[0],
                        downloadTicket: split[1],
                        username: split[2],
                        sessionId: split[3]
                    };
                    this.username = this._login.username;
                    this.loggedIn = true;
                    this.emit('login', this._login);

                    var keepAlive = function() {
                        https.get({
                            host:'login.minecraft.net',
                            path:'/session?' + querystring.stringify({
                                name: this.username,
                                session: this._login.sessionId
                            })
                        });
                        setTimeout(keepAlive, 6000 * (1000 / constants.TICKS_PER_SECOND));
                    }.bind(this);

                    keepAlive();
                } else {
                    throw new Error('Invalid Minecraft login:', chunk.toString('utf8'));
                }
            }.bind(this));
        }.bind(this));
        req.write(postData);
        req.end();
    }

    return this;
};

Socket.prototype.connect = function(options, callback) {
    if(!this.connected) {
        options = options || {};
        this.host = options.host || 'localhost';
        this.port = options.port || 25565;

        if(typeof options.username !== 'undefined') this.username = options.username;
        if(typeof options.password !== 'undefined') this.password = options.password;

        if(typeof callback === 'function') this.once('connect', callback);

        this.login(function() {
            console.log('Logged in.');
            this.once(0xfd, function(data) {
                if(data.serverId !== '-' && data.serverId !== '+') {
                    // node doesn't give us negative hashes,
                    // so gen random secrets until the hash is positive
                    var hash;
                    do {
                        this.sharedSecret = crypto.randomBytes(16);

                        hash = crypto.createHash('sha1');
                        hash.update(data.serverId, 'utf8');
                        hash.update(this.sharedSecret.toString('binary'));
                        hash.update(data.publicKey.toString('binary'));
                        hash = hash.digest('hex');
                    } while(parseInt(hash.charAt(0), 16) >= 7);

                    var publicKey = data.publicKey.toString('base64');
                    var publicKeyLines = [];

                    while(publicKey) {
                        var head = publicKey.substr(0, 64);
                        publicKey = publicKey.substr(64);
                        publicKeyLines.push(head);
                    }
                    publicKey = publicKeyLines.join('\n');

                    fs.writeFileSync(data.serverId + '.public.pem',
                         '-----BEGIN PUBLIC KEY-----\n' +
                         publicKey + '\n' +
                         '-----END PUBLIC KEY-----\n');
                    fs.writeFileSync(data.serverId + '.secret.dat', this.sharedSecret);
                    fs.writeFileSync(data.serverId + '.verify.dat', data.verifyToken);

                    child_process.exec('openssl rsautl -encrypt -pubin -inkey ./' + data.serverId +
                    '.public.pem -in ./' + data.serverId + '.secret.dat -out ./' +
                    data.serverId + '.secret.enc && openssl rsautl -encrypt -pubin -inkey ./' +
                    data.serverId + '.public.pem -in ./' + data.serverId +
                    '.verify.dat -out ./' + data.serverId + '.verify.enc', function(err, stdout) {
                        var encryptedSharedSecret = fs.readFileSync(data.serverId + '.secret.enc');
                        var encryptedVerifyToken = fs.readFileSync(data.serverId + '.verify.enc');

                        fs.unlinkSync(data.serverId + '.public.pem');
                        fs.unlinkSync(data.serverId + '.secret.dat');
                        fs.unlinkSync(data.serverId + '.verify.dat');
                        fs.unlinkSync(data.serverId + '.secret.enc');
                        fs.unlinkSync(data.serverId + '.verify.enc');

                        http.get({
                            host: 'session.minecraft.net',
                            path: '/game/joinserver.jsp?' + querystring.stringify({
                                user: this.username,
                                sessionId: this._login.sessionId,
                                serverId: hash
                            })
                        }, function(res) {
                            res.once('data', function(chunk) {
                                if(chunk.toString() === 'OK') {
                                    this.once(0xfc, function() {
                                        this.cipher = crypto.createCipheriv('aes-128-cfb8',
                                            this.sharedSecret.toString('binary'), this.sharedSecret.toString('binary'));
                                        this.cipher.setAutoPadding(false);

                                        this.decipher = crypto.createDecipheriv('aes-128-cfb8',
                                            this.sharedSecret.toString('binary'), this.sharedSecret.toString('binary'));
                                        this.decipher.setAutoPadding(false);

                                        this._encrypted = true;
                                        this.connected = true;

                                        this.write(0xcd, {payload: 0});

                                        this.emit('connect');
                                    }.bind(this));

                                    this.write(0xfc, {
                                        sharedSecret: encryptedSharedSecret,
                                        verifyTokenResponse: encryptedVerifyToken
                                    });
                                } else {
                                    throw new Error('Could not auth to server: ' + chunk.toString());
                                }
                            }.bind(this));
                        }.bind(this));
                    }.bind(this));
                } else {
                    throw new Error('Local servers are not yet supported');
                }
            }.bind(this));

            this.socket.connect(this.port, this.host, function() {
                this.write(0x02, {
                    protocolVersion: protocol.version,
                    username: this.username,
                    serverHost: this.host,
                    serverPort: this.port
                });
            }.bind(this));
        }.bind(this));
    } else {
        this.error('This socket is already connected');
    }
};

Socket.prototype.close = function(reason) {
    if(!this._closed) {
        this._closed = true;
        this.connected = false;
        this.socket.destroy();
        this.emit('close', reason || 'Connection closed by ' + (!this.isServer ? 'client' : 'server'));
    }
};

Socket.prototype.error = function(message) {
    this.emit('error', message);
};

var cat = function(b1, b2) {
    var newBuffer = new Buffer(b1.length + b2.length);
    b1.copy(newBuffer);
    b2.copy(newBuffer, b1.length);
    return newBuffer;
};

module.exports = Socket;